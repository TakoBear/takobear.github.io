<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Bear實驗室: iOS用AudioToolbox播放網路收音機 (使用FFmpeg) [Part 2]</title>
  <meta name="description" content="上次Bear實驗室報導了如何用AudioToolbox播放mp3音樂就有讀者詢問請問如果檔案格式是Apple 不支援的該怎麼辦呢?別擔心, 上篇都說了是Part I,這次進入到Part II 當然是來解決檔案格式不是Apple 支援的檔案囉!注意! 本篇內容有點長, 讀者閱讀時請保持耐心....另外注意本篇文章程...">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/blog.css">
  <link rel="stylesheet" href="/css/paginate.css">
  <link rel="canonical" href="http://www.takobear.tw/2014/01/12/bear-iosaudiotoolbox-ffmpeg-part-2.html">
  <link rel="alternate" type="application/rss+xml" title="TAKOBEAR" href="http://www.takobear.tw/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">TAKOBEAR</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
          <a class="page-link" href="/categories/">
            <i class="fa fa-tags"></i> 分類
          </a>

          <a class="page-link" href="/feed.xml">
            <i class="fa fa-rss-square"></i> RSS
          </a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Bear實驗室: iOS用AudioToolbox播放網路收音機 (使用FFmpeg) [Part 2]</h1>
    <p class="post-meta"><time datetime="2014-01-12T20:40:29+08:00" itemprop="datePublished">Jan 12, 2014</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><div>
<p><div>
<p><div><iframe src="//www.weebly.com/weebly/apps/generateVideo.php?version=2&amp;source=weebly&amp;elementid=266714458776028941&amp;user=19975491&amp;ineditor=0&amp;align=left&amp;height=auto&amp;video=1/9/9/7/19975491/ffmpeg_274.mp4&amp;image=1/9/9/7/19975491/ffmpeg_274.jpg" width="300" height="150" frameborder="0" scrolling="no" allowfullscreen="allowfullscreen"></iframe></div></p>
<p></p>
<p></p>
<p><div>上次Bear實驗室報導了<a title="" href="http://www.takobear.weebly.com/12/post/2013/09/bear-iosaudiotoolboxmp3-part-1.html" target="_blank">如何用AudioToolbox播放mp3音樂</a>
<p>就有讀者詢問請問如果檔案格式是Apple 不支援的該怎麼辦呢?</p>
<p>別擔心, 上篇都說了是Part I,</p>
<p>這次進入到Part II 當然是來解決檔案格式不是Apple 支援的檔案囉!<strong>注意! 本篇內容有點長, 讀者閱讀時請保持耐心....</strong></p>
<p><strong>另外注意本篇文章程式在iPhone 5s 恐有問題, 請謹慎注意內文說明</strong></p>
<p></p>
<p><div><!--BLOG_SUMMARY_END--></div></p>
<p><div>為避免大家記憶模糊, 讓Bear跟大家先重新復習一下, 如何判斷檔案格式是不是Apple 支援的呢?<strong>很簡單, 只要看你的URL能不能被打開就是了!!</strong>
<p>+ (void)printFileStreamBasicDescriptionFromFile:(NSString *)filePath</p>
<p>{</p>
<p>OSStatus status;</p>
<p>UInt32 size = 0;</p>
<p>AudioFileID audioFile;</p>
<p>AudioStreamBasicDescription dataFormat;</p>
<p>    // or you can use CFURLCreateFromFileSystemRepresentation to get the url</p>
<p>CFURLRef url = (CFURLRef)[NSURL fileURLWithPath:filePath];</p>
<p>    // Open the audio file to playback</p>
<p>status = AudioFileOpenURL(url, kAudioFileReadPermission, 0, &amp;audioFile);</p>
<p>if (size != noErr) {</p>
<p>NSLog(@"*** Error *** PlayAudio - play:Path: could not open audio file. Path given was: %@", filePath);</p>
<p>return;</p>
<p>} else {</p>
<p>NSLog(@"*** OK *** : %@", filePath);</p>
<p>}</p>
<p>size = sizeof(dataFormat);</p>
<p>AudioFileGetProperty(audioFile,</p>
<p>kAudioFilePropertyDataFormat,</p>
<p>&amp;size,</p>
<p>&amp;dataFormat);</p>
<p>if (size &gt; 0) {</p>
<p>// Do something  when you can get file property</p>
<p>}</p>
<p>AudioFileClose(audioFile);</p>
<p>CFRelease(url);</p>
<p>}</p>
<p>是不是很簡單呢?</p>
<p>只要AudioFileOpenURL執行後, status顯示不是noErr就表示他是屬於Apple支援的格式,</p>
<p>就可以依照之前的教學架構直接播放檔案的內容了喔!</p>
<p>(之前內容參考: <a title="" href="http://www.takobear.weebly.com/12/post/2013/09/bear-iosaudiotoolboxmp3-part-1.html" target="_blank">用AudioToolbox播放mp3音樂</a>)</p>
<p>接下來規劃一下我們需要的播放器架構, 大家請看下圖</p>
<p></p>
<p><div>
<p><div><a><img src="http://www.takobear.weebly.com/uploads/1/9/9/7/19975491/3517686_orig.png" alt="图片" /></a>
<p><div></div></p>
<p></p>
<p></p>
<p><div>會不會覺得有點複雜呢?
<p>其實我們只是把上次介紹的AudioPlayer所提供的method做了以下的變動</p>
<p>原本的SHAudioPlayer只有這個method:</p>
<p><strong>- (id)initWithAudio:(NSString *)filePath;</strong></p>
<p>這樣的概念中, 表示了我們的檔案路徑必須是Apple支援的格式, 而且原本的Player是只能播放不能停止,</p>
<p>同時也不能選擇其他codec來進行解析</p>
<p>所以這次我們擴增了Play, Stop, 還有在init的時候增加Codec的選擇</p>
<p>來擴增他的可用性而Bear要使用的Codec就是FFmpeg了!</p>
<p>(對於FFmpeg不熟悉的朋友可以參考這篇: <a title="" href="http://www.takobear.weebly.com/12/post/2013/07/ffmpeg-ios-61.html" target="_blank">FFmpeg與iOS 6.1</a>)</p>
<p>使用ffmpeg好處很多</p>
<p>包含可以支援其他不同遠端的協定(例如rtsp, mms, http)等等</p>
<p>也可以幫助我們對於一個音訊或是影像檔案成像時的概念作完整的理解!</p>
<p>對於上圖的說明, 在於我們要實際播放一個檔案時</p>
<p>每一段的音訊呈現(或是視訊呈現)都是由每一個frame 為單位</p>
<p>frame以一個數學概念來看就是矩陣Matrix</p>
<p><strong>(Bear在這邊不做細節解釋, 讓Bear之後還能騙文章數!)</strong></p>
<p>於是接下來讓Bear先介紹整個AudioPlayer的程式架構吧</p>
<p>看到AuidoPlayer.h的宣告如下</p>
<p>#import &lt;Foundation/Foundation.h&gt;</p>
<p>#import &lt;AudioToolbox/AudioToolbox.h&gt;</p>
<p>#import "AudioPacketQueue.h"</p>
<p>#include "libavformat/avformat.h"</p>
<p>#include "libavutil/opt.h"</p>
<p>#include "libswresample/swresample.h"</p>
<p>typedef enum {</p>
<p>eAudioRunning   = 1,</p>
<p>eAudioStop      = 2</p>
<p>}eAudioType;</p>
<p>@interface AudioPlayer : NSObject</p>
<p>@property BOOL bIsADTSAAS;</p>
<p>- (id)initAuido:(AudioPacketQueue *)audioQueue withCodecCtx:(AVCodecContext *)aCodecCtx;</p>
<p>- (void)play;</p>
<p>- (void)stop:(BOOL)bStopImmediatelly;</p>
<p>- (void)decodeAudioFile:(NSString *)filePathIn</p>
<p>toPCMFile:(NSString *)filePathOut</p>
<p>withCodecCtx:(AVCodecContext *)pAudioCodecCtx</p>
<p>withFormat:(AVFormatContext *)pFormatCtx</p>
<p>withStreamIdx:(int)audioStream;</p>
<p>- (int)getStatus;</p>
<p>- (int)putAVPacket:(AVPacket *)pkt;</p>
<p>- (int)getAVPacket:(AVPacket *)pkt;</p>
<p>- (void)freeAVPacket:(AVPacket *)pkt;</p>
<p>@end</p>
<p>接下來Bear就來一個個介紹每個method的架構了</p>
<p>首先到AudioPlayer.m檔內</p>
<p>你需要import的library如下:</p>
<p>#import "AudioPlayer.h"</p>
<p> #import &lt;AVFoundation/AVFoundation.h&gt;</p>
<p> #import "AudioUtilities.h"</p>
<p>// According to Apple guide, the number of audio queue buffers is recommended to 3</p>
<p> #define NUM_BUFFER                      3</p>
<p> #define AVCODEC_MAX_AUDIO_FRAME_SIZE 192000</p>
<p> #define AUDIO_BUFFER_SECONDS            1</p>
<p> #define AUDIO_BUFFER_QUANTITY           3</p>
<p> #define DECODE_AUDIO_BY_FFMPEG          1</p>
<p>這邊定義了好幾個參數</p>
<p>NUM_BUFFER 代表會分配三段BUFFER 給AudioToolbox進行encoder, decoder, 這個數字是由Apple官方建議的</p>
<p>Bear就直接採用過來了!</p>
<p>接下來是Audio的單一frame最大大小為19200 bytes (約20kb)</p>
<p>另外兩個則不是如此重要, Bear這邊先偷懶不介紹</p>
<p>接下來我們看全域變數部分</p>
<p>@interface AudioPlayer ()</p>
<p>{</p>
<p>  // ==  This is just refereneced from Apple Queue Service Programming Guide</p>
<p>// =============================================================</p>
<p>   AudioStreamBasicDescription mDataFormat;                // Represent the audio format </p>
<p>AudioQueueRef               mQueue;                     // The playback audio queue created by this app</p>
<p>AudioQueueBufferRef         mBuffers[NUM_BUFFER];       // An array holding pointers to the audio queue buffer </p>
<p>AudioFileID                 mAudioFile;                 // Audio file representing the audio file you want to play</p>
<p>UInt32                      bufferByteSize;             // size in bytes for each audio queue, use DervieBufferSize to get</p>
<p>SInt64                      mCurrentPacket;             // The packet index for the next packet to play in your audiio</p>
<p>UInt32                      mNumPacketsToRead;          // Number of packets to read on each audio queue's callback</p>
<p>AudioStreamPacketDescription *mPacketDescs;             // For VBR audio data, the array of packet descriptions for the file being played. For CBR data, the value of this field is NULL.</p>
<p>bool                        mIsRunning;                 // A boolean value indicates the audio queue is running or not</p>
<p>// =============================================================</p>
<p>bool isFormatVBR;</p>
<p>AVCodecContext              *aCodecCtx;</p>
<p>AudioPacketQueue            *audioPacketQueue;</p>
<p>AVFrame                     *pAudioFrame;</p>
<p>SwrContext                  *pSwrCtx;</p>
<p>long lastStartTime;</p>
<p>}</p>
<p>- (UInt32)putAVPacketsIntoAudioQueue:(AudioQueueBufferRef)audioQueueBuffer;</p>
<p>- (int)DeriveBufferSize:(AudioStreamBasicDescription)ASBdescription withPakcetSize:(UInt32)maxPacketSize andSeconds:(Float64)seconds;</p>
<p>@end</p>
<p>接下來解析幾個重要的method</p>
<p>- (id)initAuido:(AudioPacketQueue *)audioQueue withCodecCtx:(AVCodecContext *)aCodecCtx</p>
<p>{</p>
<p>     //  1. 初始化參數</p>
<p>int i = 0;</p>
<p>int audio_index = 1;</p>
<p>int vBufferSize = 0;</p>
<p>int err;</p>
<p>//  2. Support audio play when screen is locked</p>
<p>NSError *setCategoryError = nil;</p>
<p>NSError *activationError = nil;</p>
<p>[[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:&amp;setCategoryError];</p>
<p>[[AVAudioSession sharedInstance] setActive:YES error:&amp;activationError];</p>
<p>// 3. 如果有建立過Queue, 直接設定, 沒有的話就進行初始化 = &gt; 每一個Player只包含一個audio packet queue, 代表目前正在播放的音訊內容</p>
<p>if (audioQueue) {</p>
<p>audioPacketQueue = audioQueue;</p>
<p>} else {</p>
<p>audioPacketQueue = [[AudioPacketQueue alloc] initQueue];</p>
<p>}</p>
<p> // 4. 設定Codec的context內容, 以及用ffmpeg的API : avcodec_alloc_frame()初始化聲音的frame內容</p>
<p>aCodecCtx = pAudioCodecCtx;</p>
<p>pAudioFrame = avcodec_alloc_frame();</p>
<p>if (audio_index &gt;= 0) {</p>
<p>       // 5. 設定音訊格式內容, 使用AudioStreamBasicDescription這個結構體(struct)</p>
<p>AudioStreamBasicDescription audioFormat = {0};</p>
<p>audioFormat.mFormatID = -1;</p>
<p>audioFormat.mSampleRate = pAudioCodecCtx-&gt;sample_rate;</p>
<p>audioFormat.mFormatFlags = 0;</p>
<p><strong>       // 6. 利用Codec 的結構資訊: codec_id來判定要使用哪種解析格式播放音樂</strong></p>
<p>switch (pAudioCodecCtx-&gt;codec_id) {</p>
<p>case AV_CODEC_ID_WMAV1:</p>
<p>case AV_CODEC_ID_WMAV2:</p>
<p>audioFormat.mFormatID = kAudioFormatLinearPCM;</p>
<p>break;</p>
<p>case AV_CODEC_ID_MP3:</p>
<p>audioFormat.mFormatID = kAudioFormatMPEGLayer3;</p>
<p>break;</p>
<p>case AV_CODEC_ID_AAC:</p>
<p>audioFormat.mFormatID = kAudioFormatMPEG4AAC;</p>
<p>audioFormat.mFormatFlags = kMPEG4Object_AAC_Main;</p>
<p>break;</p>
<p>case AV_CODEC_ID_PCM_ALAW:</p>
<p>audioFormat.mFormatID = kAudioFormatALaw;</p>
<p>break;</p>
<p>case AV_CODEC_ID_PCM_MULAW:</p>
<p>audioFormat.mFormatID = kAudioFormatULaw;</p>
<p>break;</p>
<p>case AV_CODEC_ID_PCM_U8:</p>
<p>audioFormat.mFormatID = kAudioFormatLinearPCM;</p>
<p>break;</p>
<p>default:</p>
<p>NSLog(@"Error: audio format '%s' (%d) is not supported", pAudioCodecCtx-&gt;codec_name, pAudioCodecCtx-&gt;codec_id);</p>
<p>audioFormat.mFormatID = kAudioFormatAC3;</p>
<p>break;</p>
<p>}</p>
<p>if (audioFormat.mFormatID != -1) {</p>
<p><strong>            // 7. 成功解析出來音訊以後, 把ffmpeg得到的資訊輸入給audioFormat (也就是 AudioStreamBasicDescription)</strong></p>
<p>audioFormat.mFormatID = kAudioFormatLinearPCM;</p>
<p>audioFormat.mFormatFlags = kAudioFormatFlagsCanonical;</p>
<p>audioFormat.mSampleRate = pAudioCodecCtx-&gt;sample_rate;</p>
<p>audioFormat.mBitsPerChannel = 8 * av_get_bytes_per_sample(AV_SAMPLE_FMT_S16);</p>
<p>audioFormat.mChannelsPerFrame = pAudioCodecCtx-&gt;channels;</p>
<p>audioFormat.mBytesPerFrame  = pAudioCodecCtx-&gt;channels * av_get_bytes_per_sample(AV_SAMPLE_FMT_S16);</p>
<p>audioFormat.mBytesPerPacket = pAudioCodecCtx-&gt;channels * av_get_bytes_per_sample(AV_SAMPLE_FMT_S16);</p>
<p>audioFormat.mFramesPerPacket = 1;</p>
<p>audioFormat.mReserved = 0;</p>
<p><strong>            // 8. 這邊很重要要注意的是: FFmpeg可能會使我們得到32, 16 或是8bits的聲音資料</strong></p>
<p><strong>           //  如果得到32bits的結果, 必須要把它轉換成16bits (32bits 的關鍵字是AV_SAMPLE_FMT_FLTP)</strong></p>
<p><strong>           // 不然播放時會有雜音產生! (16bits的關鍵字是AV_SAMPLE_FMT_S16)</strong></p>
<p><strong>           // 我們使用swr_alloc_set_opts這個API就能直接進行重新分配sample rate了
<p>             // The default data defined by Apple is 16 bits</p>
<p>// If we got 32 or 8 bits, then convert it into 16 bits</p>
<p>if (pAudioCodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_FLTP) {</p>
<p>if (pAudioCodecCtx-&gt;channel_layout != 0) {</p>
<p>pSwrCtx = swr_alloc_set_opts(pSwrCtx,</p>
<p>pAudioCodecCtx-&gt;channel_layout,</p>
<p>AV_SAMPLE_FMT_S16,</p>
<p>pAudioCodecCtx-&gt;sample_rate,</p>
<p>pAudioCodecCtx-&gt;channel_layout,</p>
<p>AV_SAMPLE_FMT_FLTP,</p>
<p>pAudioCodecCtx-&gt;sample_rate,</p>
<p>0,</p>
<p>0);</p>
<p>} else {</p>
<p>pSwrCtx = swr_alloc_set_opts(pSwrCtx,</p>
<p>pAudioCodecCtx-&gt;channels + 1,</p>
<p>AV_SAMPLE_FMT_S16,</p>
<p>pAudioCodecCtx-&gt;sample_rate,</p>
<p>pAudioCodecCtx-&gt;channels+1,</p>
<p>AV_SAMPLE_FMT_FLTP,</p>
<p>pAudioCodecCtx-&gt;sample_rate,</p>
<p>0,</p>
<p>0);</p>
<p>}</p>
<p>NSLog(@"sample_rate=%d, channels=%d, channel_layout=%lld",pAudioCodecCtx-&gt;sample_rate, pAudioCodecCtx-&gt;channels, pAudioCodecCtx-&gt;channel_layout);</p>
<p>                <strong> // 9. 初始化pSwrCtx, 這樣之後才能用它去顯現音訊的內容</strong></p>
<p>if (swr_init(pSwrCtx)&lt;0) {</p>
<p>NSLog(@"swr_init() for AV_SAMPLE_FMT_FLTP fail");</p>
<p>return nil;</p>
<p>}</p>
<p>} else if(pAudioCodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_S16P) {</p>
<p>pSwrCtx = swr_alloc_set_opts(pSwrCtx,</p>
<p>pAudioCodecCtx-&gt;channel_layout,</p>
<p>AV_SAMPLE_FMT_S16,</p>
<p>pAudioCodecCtx-&gt;sample_rate,</p>
<p>pAudioCodecCtx-&gt;channel_layout,</p>
<p>AV_SAMPLE_FMT_S16P,</p>
<p>pAudioCodecCtx-&gt;sample_rate,</p>
<p>0,</p>
<p>0);</p>
<p>if(swr_init(pSwrCtx)&lt;0)</p>
<p>{</p>
<p>NSLog(@"swr_init() for AV_SAMPLE_FMT_S16P fail");</p>
<p>return nil;</p>
<p>}</p>
<p>} else if (pAudioCodecCtx-&gt;sample_fmt == AV_SAMPLE_FMT_U8)</p>
<p>{</p>
<p>pSwrCtx = swr_alloc_set_opts(pSwrCtx,</p>
<p>1,</p>
<p>AV_SAMPLE_FMT_S16,</p>
<p>pAudioCodecCtx-&gt;sample_rate, 1,</p>
<p>AV_SAMPLE_FMT_U8,</p>
<p>pAudioCodecCtx-&gt;sample_rate,</p>
<p>0,</p>
<p>0);</p>
<p>if(swr_init(pSwrCtx)&lt;0)</p>
<p>{</p>
<p>NSLog(@"swr_init()  fail");</p>
<p>return nil;</p>
<p>}</p>
<p>}</p>
<p><strong>            // 10. 配置完成sample rate有關的問題後, 使用AudioToolbox的API把callback加入到Queue裡面</strong></p>
<p>if ((err = AudioQueueNewOutput(&amp;audioFormat, HandleOutputBuffer, (void *)(self), NULL, NULL, 0, &amp;mQueue)) != noErr) {</p>
<p>NSLog(@"Error creating audio output queue");</p>
<p>} else {</p>
<p>                // Succeed to create a new queue to handle output buffer</p>
<p>if (pAudioCodecCtx-&gt;bit_rate == 0) {</p>
<p>pAudioCodecCtx-&gt;bit_rate = 0x100000; // 1048576 bits</p>
<p>}</p>
<p>if (pAudioCodecCtx-&gt;frame_size == 0) {</p>
<p>pAudioCodecCtx-&gt;frame_size = 1024;</p>
<p>}</p>
<p>               <strong>// 11. 取出目前音訊格式的buffersize大小, 這邊是參考Apple官方example完成</strong></p>
<p>vBufferSize = [self DeriveBufferSize:audioFormat withPakcetSize:pAudioCodecCtx-&gt;bit_rate/8 andSeconds:AUDIO_BUFFER_SECONDS];</p>
<p> <strong>// 12. 跑3個預先區分好的queue, 分配給每一個queue 的buffer大小好進行播放</strong></p>
<p>for (i = 0; i &lt; AUDIO_BUFFER_QUANTITY; i++) {</p>
<p>if ((err = AudioQueueAllocateBufferWithPacketDescriptions(mQueue, vBufferSize, 1, &amp;mBuffers[i])) != noErr) {</p>
<p>NSLog(@"Error when allocating audio buffer");</p>
<p><strong>// 13. 失敗的話停止播放</strong></p>
<p>AudioQueueDispose(mQueue, YES);</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>} /* End of if */</p>
<p>}</p>
<p><strong>   // 14. 設定播放音量大小</strong></p>
<p>Float32 gain = 1.0;</p>
<p>AudioQueueSetParameter(mQueue, kAudioQueueParam_Volume, gain);</p>
<p>return self;</p>
<p>}</p>
<p>到這邊為止, 是最核心的初始化參數部分</p>
<p>接下來Bear會以架構圖概念來解釋整段Code的運作</p>
<p>有需要看原始碼部分的朋友直接到文章末的github連結下載Code就行囉!</p>
<p></p>
<p><div>
<p><div><a><img src="http://www.takobear.weebly.com/uploads/1/9/9/7/19975491/7689362_orig.jpg" alt="图片" /></a>
<p><div></div></p>
<p></p>
<p></p>
<p><div>第一段初始化的修改就是這樣!!
<p>是不是有點巨大呢?接下來部分內容會比較簡單</p>
<p>play的method中只要使用以下這一段程式碼會開始執行queue</p>
<p><strong>AudioQueueStart(mQueue, nil);</strong></p>
<p>stop的部分則可以利用</p>
<p><strong>AudioQueueStop(mQueue, bStopImmediatelly);</strong> 停止播放</p>
<p>再來就是</p>
<p>檔案轉換的過程主要是以下三部分, 也就是使用FFmpeg把AAC檔案的格式給轉換成PCM檔案格式</p>
<p>也就是以下Method:</p>
<p><strong>- (UInt32)putAVPacketsIntoAudioQueue:(AudioQueueBufferRef)audioQueueBuffer</strong></p>
<p>對於Apple支援的AAC格式檔案, 這邊只需要把記憶體複製出來就行</p>
<p>那如果是Apple不支援的格式呢</p>
<p>則是採取以下步驟</p>
<p><strong><u>1. 使用 FFMPEG 讀取 AVPacket</u></strong></p>
<p>av_read_frame(pFormatCtx, &amp; AudioPacket)</p>
<p><strong><u>2. 將 AVPacket 解開為 AVFrame</u></strong></p>
<p>av_samples_get_buffer_size(pAVFrame1) 用來取得frame的buffer大小</p>
<p>avcodec_decode_audio4(pAudioCodecCtx, pAudioFrame, &amp;gotFrame, &amp;AudioPacket);</p>
<p><strong><u>3. 將 AVFrame 複製至 Audio Queue 對應的 buffer</u></strong></p>
<p>此處需注意的是ffmpeg 所解開的檔案，其bitsPerSample 可能為32,16, 8 bits，若其bitsPerSample 不同，則需要進行轉換，以下的例子便需要將 AV_SAMPLE_FMT_FLTP (U32) 轉換至 AV_SAMPLE_FMT_S16 (S16)，才能夠正常播放。否則播放時便會有許多雜音出現。</p>
<p><strong><u>4. 轉換audio </u></strong></p>
<p>outCount = swr_convert(pSwrCtx,</p>
<p>(uint8_t **)(&amp;pOut),</p>
<p>in_samples,</p>
<p>(const uint8_t **)pAVFrame1-&gt;extended_data,</p>
<p>in_samples);</p>
<p><strong><u>5. 轉換完成後去更新bufferRef的資訊: </u></strong></p>
<p>bufferRef-&gt;mPacketDescriptions[bufferRef-&gt;mPacketDescriptionCount].mStartOffset = bufferRef-&gt;mAudioDataByteSize;</p>
<p>bufferRef-&gt;mPacketDescriptions[bufferRef-&gt;mPacketDescriptionCount].mDataByteSize = data_size;</p>
<p>bufferRef-&gt;mPacketDescriptions[bufferRef-&gt;mPacketDescriptionCount].mVariableFramesInPacket=1;</p>
<p>bufferRef-&gt;mAudioDataByteSize += data_size;</p>
<p><strong><u>6. 更新資訊後重新加入到queue中</u></strong></p>
<p>err = AudioQueueEnqueueBuffer(mQueue,</p>
<p>bufferRef,</p>
<p>0,</p>
<p>NULL))</p>
<p>至此, 我們就初步完成了新的Audio Player 架構了喔!</p>
<p>但是Bear實驗室的教學還沒結束</p>
<p>下一篇我們會實際應用這個player去制作網路收音機!</p>
<p>有興趣的版友千萬別錯過喔!</p>
<p>想先看到完整的程式碼只要到這邊下載就行了:</p>
<p><a title="" href="https://github.com/shouian/MMSRadioWithFFmpeg" target="_blank">https://github.com/shouian/MMSRadioWithFFmpeg</a></p>
<p>下篇教學大家千萬別錯過喔!</p>
<p>更多有趣消息, 請繼續關注Takobear粉絲團!</p>
<p></p>
<p><div></div></p>
<p><div>
<p><div id="166643853152053577" align="left"><script async="">// < ![CDATA[</p>
<p>// ]]></script><!-- Takobear 728x90 --><script>// < ![CDATA[</p>
<p> (adsbygoogle = window.adsbygoogle || []).push({});</p>
<p>// ]]></script></div></p>
<p></p>
</div></p></div></p></div></p></div></p></strong></p></div></p></div></p></div></p></div></p></div></p></div></p></div></p>

  </div>

</article>


<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
        this.page.url = "http:\/\/www.takobear.tw\/2014\/01\/12\/bear-iosaudiotoolbox-ffmpeg-part-2\/";
        this.page.identifier = "677 http:\/\/www.takobear.tw\/201702608526356260322804024687\/bear-iosaudiotoolbox-ffmpeg-part-2";
    };

    (function() {
        var d = document, s = d.createElement('script');

        s.src = '//takobear.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-2">
        <ul class="contact-list">
          <li>TAKOBEAR</li>
          <li><a href="mailto:takobearx@gmail.com">takobearx@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-1 footer-col-right">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/TakoBear">
  <span class="icon"><i class="fa fa-github fa-fw"></i></span>
  <span class="username">TakoBear</span>
</a>

          </li>
          

          
          <li>
            <a href="https://www.facebook.com/funnytechandnews">
  <span class="icon"><i class="fa fa-facebook fa-fw"></i></span>
  <span class="username">funnytechandnews</span>
</a>

          </li>
          
        </ul>
      </div>
    </div>

    <div class="footer-license">
      2013-2016 TakoBear. All rights reserved.
    </div>
  </div>

</footer>


  </body>

</html>
